<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by perltidy on Thu Nov 30 18:10:54 2006 -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>2006 Perl Advent Calendar: Good things come in small packages</title>
<link rel="stylesheet" href="../style.css" type="text/css" /></head>
<body>
<h1><a href="../">Perl Advent Calendar 2006-12</a>-01</h1>
<h2 align="center">Good things come in small packages</h2>
<h3 align="center">by Jerrad Pierce</h3>

<blockquote style="padding: 1em; border: 2px ridge black; background-color:#eee">
Welcome to another edition of the Perl Advent Calendar. With some help from
The Perl Foundation/Perl Mongers crew I've created PerlAdvent.PM here, where
the current and future calendars can live; we are also working on providing
a home for all of the previous calendars as well.  I hope to delegate more of
the writing duties to a wider variety of voices from the community with the
support of several other mongers. And now, for the first installment. Enjoy.
</blockquote>

<p>Once you get around to reading it, you'll notice that today's code sample is
extraordinarily short. That's because our featured module isn't about providing
you with a toolkit but rather a tool. At one point or another you're going to
write a program that's just t o o &nbsp; d a m n &nbsp; s l o w. At which point
your next step should be to profile your code, and luckily perl has shipped
with one named <tt>Devel::DProf</tt> since 5.6.0. DProf is great, you run it
via the debugger, it logs some timing information, and then you run its buddy
<tt>drofpp</tt> to see where your code is lollygagging.</p>

<p>The problem is, DProf may not always works for your circumstances. DProf
tracks how much time is spent in each subroutine, which work great for verbose
OO code. But what if you have beefy subs which, for one reason or another, you
aren't planning on refactoring into lots of itty bitty pieces? And which pieces
would make the most sense to break up? Or, what if you have no subroutines like
our simple Monte Carlo pi-calculation example below? Well, in the latter case
<tt>dprofpp</tt> won't report anything!
</p>

<p>Enter <tt><a href="http://search.cpan.org/search?module=Devel::SmallProf">Devel::SmallProf</a></tt>,
the linewise profiler. SmallProf lacks a pretty-printing sidekick counterpart
to <tt>dprofpp</tt>, but more than makes up for it in utility because SmallProf
can tell you exactly which statements are consuming the most processor time.
Of course, this more intensive introspection comes at a price<sup>
<a href="#1">1</a></sup>. Profiling with SmallProf is frequently an
order of magnitude slower than with DProf! If possible then, it is usually
beneficial to first profile with DProf to determine the general problem area
and then use SmallProf's <tt>$DB::profile</tt> to toggle profiling for only
the areas of interest.
</p>
<p>
Here is some sample SmallProf "output".
Note that the column labels have sorted to the bottom of the listing.
</p>
<pre>
$ perl -d:SmallProf mod1.pl
$ sort -k 2nr,2 smallprof.out #POD provided command<span class="c">
    99999 0.383615 1.879000    15:  printf "PI ~ %1.8f after %0${COUNT}i
    99999 0.303463 1.815000    10:  if( ($x**2 + $y**2) &lt;= 1 ){
    99999 0.200046 1.721000     6:  my $x = rand();
    99999 0.178753 1.713000     7:  my $y = rand();
    78489 0.094622 1.257000    11:    $HIT++;
        1 0.000008 0.000000     5:for(my $i = 1; $i &lt; 10**$COUNT; ++$i){
        1 0.000006 0.000000     2:my $COUNT = 5; #Orders of magnitude
        1 0.000002 0.000000     3:my $HIT = 0;
        1 0.000002 0.000000    17:}
                              Profile of mod1.pl                       Page 1
           ================ SmallProf version 1.15 ================
        0 0.000000 0.000000     1:#!/usr/bin/perl
        0 0.000000 0.000000     4:
        0 0.000000 0.000000     8:
        0 0.000000 0.000000     9:  #The equals condition is neglected in many
        0 0.000000 0.000000    12:  }
        0 0.000000 0.000000    13:
        0 0.000000 0.000000    14:  #Multiply by 4 as we're using a single
        0 0.000000 0.000000    16:    ($i % 1_000) == 0;
       =================================================================
    count wall tm  cpu time line</span>
</pre>

After a brief rewrite merging four of the five slowest and non-trivial lines
(6-11) we get a denser/cleaner version which executes much more quickly.

We can also get more DWIMly sorted results using the more cumbersome command
here provided by Tom Metro.

<pre>
$ perl -d:SmallProf mod1b.pl
$ tail +4 smallprof.out | sort -t '\0' -k 1.29r,1.29 -k 1.11nr,1.18<span class="c">
    count wall tm  cpu time line
    99999 0.575161 1.968000     6:  $HIT++ if rand()**2 + rand()**2 &lt;= 1;
    99999 0.462837 1.896000     8:  printf "PI ~ %1.8f after %0${COUNT}i
        1 0.000010 0.000000     5:for(my $i = 1; $i &lt; 10**$COUNT; ++$i){
        1 0.000005 0.000000     2:my $COUNT = 5; #Orders of magnitude
        1 0.000004 0.000000     3:my $HIT = 0;
        1 0.000003 0.000000    10:}
        0 0.000000 0.000000     1:#!/usr/bin/perl
        0 0.000000 0.000000     4:
        0 0.000000 0.000000     7:
        0 0.000000 0.000000     9:    ($i % 1_000) == 0;</span>
</pre>

<table border="1">
<tr><td></td><th>count</th><th>wall time</th><th>cpu time</th></tr>
<tr><td>before</td><td>478489</td><td>1.160517</td><td align="right">8.385</td></tr>
<tr><td>after</td><td>200002</td><td>1.023103</td><td align="right">3.931</td></tr>
</table>

<div style="float:right; width: 50%; position: relative; top: -5em">Note that
the current maintainer of SmallProf has created an XS version&mdash;requiring
5.8.8 or better&mdash;dubbed
<tt><a href="http://search.cpan.org/search?module=Devel::FastProf">Devel::FastProf</a></tt>.
It reportedly only incurs an approximately 5x speed penatly, and provides a
result viewer</div>

<p>P.S. Yes, I am aware that the final result doesn't get printed ;-)</p>

<h1><a href="mod1.pl">mod1.pl</a></h1>
<hr />
<pre>
   1 #!/usr/bin/perl
   2 <span class="k">my</span> <span class="i">$COUNT</span> = <span class="n">5</span><span class="sc">;</span> <span class="c">#Orders of magnitude</span>
   3 <span class="k">my</span> <span class="i">$HIT</span> = <span class="n">0</span><span class="sc">;</span>
   4 
   5 <span class="k">for</span><span class="s">(</span><span class="k">my</span> <span class="i">$i</span> = <span class="n">1</span><span class="sc">;</span> <span class="i">$i</span> &lt; <span class="n">10</span>**<span class="i">$COUNT</span><span class="sc">;</span> ++<span class="i">$i</span><span class="s">)</span><span class="s">{</span>
   6   <span class="k">my</span> <span class="i">$x</span> = <span class="k">rand</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
   7   <span class="k">my</span> <span class="i">$y</span> = <span class="k">rand</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
   8 
   9   <span class="c">#The equals condition is neglected in many implementations</span>
  10   <span class="k">if</span><span class="s">(</span> <span class="s">(</span><span class="i">$x</span>**<span class="n">2</span> + <span class="i">$y</span>**<span class="n">2</span><span class="s">)</span> &lt;= <span class="n">1</span> <span class="s">)</span><span class="s">{</span>
  11     <span class="i">$HIT</span>++<span class="sc">;</span>
  12   <span class="s">}</span>
  13 
  14   <span class="c">#Multiply by 4 as we're using a single quadrant</span>
  15   <span class="k">printf</span> <span class="q">&quot;PI ~ %1.8f after %0${COUNT}i points\n&quot;</span><span class="cm">,</span> <span class="n">4</span>*<span class="i">$HIT</span>/<span class="i">$i</span><span class="cm">,</span> <span class="i">$i</span> <span class="k">if</span>
  16     <span class="s">(</span><span class="i">$i</span> % <span class="n">1_000</span><span class="s">)</span> == <span class="n">0</span><span class="sc">;</span>
  17 <span class="s">}</span>
</pre>

<h1><a href="mod1b.pl">mod1b.pl</a></h1>
<hr />
<pre>
   1 #!/usr/bin/perl
   2 <span class="k">my</span> <span class="i">$COUNT</span> = <span class="n">5</span><span class="sc">;</span> <span class="c">#Orders of magnitude</span>
   3 <span class="k">my</span> <span class="i">$HIT</span> = <span class="n">0</span><span class="sc">;</span>
   4 
   5 <span class="k">for</span><span class="s">(</span><span class="k">my</span> <span class="i">$i</span> = <span class="n">1</span><span class="sc">;</span> <span class="i">$i</span> &lt; <span class="n">10</span>**<span class="i">$COUNT</span><span class="sc">;</span> ++<span class="i">$i</span><span class="s">)</span><span class="s">{</span>
   6   <span class="i">$HIT</span>++ <span class="k">if</span> <span class="k">rand</span><span class="s">(</span><span class="s">)</span>**<span class="n">2</span> + <span class="k">rand</span><span class="s">(</span><span class="s">)</span>**<span class="n">2</span> &lt;= <span class="n">1</span><span class="sc">;</span>
   7 
   8   <span class="k">printf</span> <span class="q">&quot;PI ~ %1.8f after %0${COUNT}i points\n&quot;</span><span class="cm">,</span> <span class="n">4</span>*<span class="i">$HIT</span>/<span class="i">$i</span><span class="cm">,</span> <span class="i">$i</span> <span class="k">if</span>
   9     <span class="s">(</span><span class="i">$i</span> % <span class="n">1_000</span><span class="s">)</span> == <span class="n">0</span><span class="sc">;</span>
  10 <span class="s">}</span>
</pre>
<a name="1">1.</a> Because of its line orientation, you can get odd results
from SmallProf for code that uses AUTOLOAD.
</body>
</html>
